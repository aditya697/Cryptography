# ***CRYPTOHACKS***

## ***INTRODUCTION***

### *Finding Flag*

The flag is given in the question.

*```FLAG:- crypto{y0ur_f1rst_fl4g)```*

### *Great snakes*

By running the program we get the flag.

*```FLAG:- crypto{z3n_0f_pyth0n}```*

### *Networks Attacks*

We are given a .py file.
If we change buy:clothes to buy:flags and run the program we will get the answer.

*```FLAG:- crypto{sh0pp1ng_f0r_fl4g5}```*

## ***GENERAL***

### *ASCII*

We are given a list of ascii value if we convert them into text we get the flag.

```
ini_list = [99, 114, 121, 112, 116, 111, 123, 65, 83, 67, 73, 73, 95, 112, 114, 49, 110, 116, 52, 98, 108, 51, 125]
res = "" 
for val in ini_list:
      res = res + chr(val)
print ("Resultant string", str(res))
```

using this program we get the flag

*```FLAG:- crypto{ASCII_pr1nt4bl3}```*

### *HEX*

We are given a hex string. To get the flag we should decode from hex. We can use ```.decode('hex')```

Or by this progra we can obtain the flag.
```
x = '63727970746f7b596f755f77696c6c5f62655f776f726b696e675f776974685f6865785f737472696e67735f615f6c6f747d'
byte_array = bytearray.fromhex(x)
print(byte_array)
```
We get the using the code.

*```FLAG:- crypto{You_will_be_working_with_hex_strings_a_lot}```*

### *Base64*

We are given a hex string. First we have to decode from hex.

Now the output of .decode('hex') or the above program we get string in bytes
```'r\xbc\xa9\xb6\x8f\xc1j\xc7\xbe\xeb\x8f\x84\x9d\xca\x1d\x8ax>\x8a\xcf\x96y\xbf\x92i\xf7\xbf'```

By encodeing the bytes using the following program we get the flag.

```
from base64 import b64encode
b64encode(byte_arr)
```

*```FLAG:-crypto/Base+64+Encoding+is+Web+Safe/```*

### *Bytes to Big Integers*

We are given long integers.

By using long_to_bytes , bytes_to_long we convert long integers to bytes and vice versa.

By using the following program we get the flag.
```
>>> from Crypto.Util.number import bytes_to_long, long_to_bytes    
>>> val = 11515195063862318899931685488813747395775516287289682636499965282714637259206269
>>> long_to_bytes(val) 
```

*```FLAG:- crypto{3nc0d1n6_4ll_7h3_w4y_d0wn}```*

### *Encoding Challenge*

We are given a .py file. If we rreach 100th level we will get the flag.

## ***XOR***

### *XOR Starter*

We are given a word. And that word is XORed with 13.
So we conver word in binary then XOR with binary of 13. We get the flag
```
data = "label"
flag = ''
for c in data:
    flag += chr(ord(c) ^ 13)
print(flag)
```
Since the flag mentioned is crypto{string}.

*```FLAG:- crypto{aloha}```*

## *XOR Properties*

We are given
```
>>>KEY1 = a6c8b6733c9b22de7bc0253266a3867df55acde8635e19c73313
>>>KEY2 ^ KEY1 = 37dcb292030faa90d07eec17e3b1c6d8daf94c35d4c9191a5e1e
>>>KEY2 ^ KEY3 = c1545756687e7573db23aa1c3452a098b71a7fbf0fddddde5fc1
>>>FLAG ^ KEY1 ^ KEY3 ^ KEY2 = 04ee9855208a2cd59091d04767ae47963170d1660df7f56f5faf
```
We have to first decode from hex.By using the program we can get the flag coverting into hex.
```
import codecs
k1 = int('a6c8b6733c9b22de7bc0253266a3867df55acde8635e19c73313', 16)
k2_3 = int('c1545756687e7573db23aa1c3452a098b71a7fbf0fddddde5fc1', 16)
flag = int('04ee9855208a2cd59091d04767ae47963170d1660df7f56f5faf',16)
flag = k1 ^ k2_3 ^ flag
print(codecs.decode(('%x' %flag),'hex_codec'))
```
*```FLAG:- crypto{x0r_i5_ass0c1at1v3}```*

### *Favorite Bytes*

We are given a hex,which we have decode.
Then since it is single byte xor the length of the key is 1.
Therefore we can say there will be 256 that we try and xor to get the flag.
By using the the code we can find the flag.
```
def single_byte_xor(input, key):
    if len(chr(key)) != 1:
      raise "KEY LENGTH EXCEPTION: In single_byte_xor key must be 1 byte long!"

    output = b''
    for b in input:
        output += bytes([b ^ key])

    try:
        return output.decode("utf-8")
    except:
        return "Cannot Decode some bytes"

decoded = bytearray.fromhex("73626960647f6b206821204f21254f7d694f7624662065622127234f726927756d")
result = {}
for i in range(256):
    result[i] = (single_byte_xor(decoded, i))
for s in result.values():
    if ("crypto" in s):
        print(s)
```
 
*```FLAG:-crypto{0x10_15_my_f4v0ur173_by7e}```*

### *You either know, XOR you don't*

We are given a hex,which we have to decode.
Here the key length is unkown,So we have to brute to get the flag.
But we know we know the starting few words of the Flag. 
By using we can find that we can find the flag. By using this program
```
def brute(input, key):
    if len(input) != len(key):
        return "Failed!"

    output = b''
    for b1, b2 in zip(input, key):
        output += bytes([b1 ^ b2])
    try:
        return output.decode("utf-8")
    except:
        return "Cannot Decode some bytes"

cipher = bytearray.fromhex("0e0b213f26041e480b26217f27342e175d0e070a3c5b103e2526217f27342e175d0e077e263451150104")
key_part = brute(cipher[:7], "crypto{".encode())
key = (key_part + "y").encode()
key += key * int((len(cipher) - len(key))/len(key))
key += key[:((len(cipher) - len(key))%len(key))]
plain = brute(cipher, key)
print(plain)
```

*```FLAG:-crypto{1f_y0u_Kn0w_En0uGH_y0u_Kn0w_1t_4ll}```*

## ***MATHEMATICS***

### *GREATEST COMMON FACTOR*

We are asked to find gcd of a = 66528, b = 52920.

By using this we can find
```
import math
a = 66528 
b = 52920
print(math.gcd(a,b))
```
*```1512```*

### *EXTENDED GCD*

We are asked to find u,v using euclid's gcd method.

By using the code we can get the answer.
```
def egcd(a, b):
    x,y, u,v = 0,1, 1,0
    while a != 0:
        q, r = b//a, b%a
        m, n = x-u*q, y-v*q
        b,a, x,y, u,v = a,r, u,v, m,n
    gcd = b
    return gcd, x, y

print(egcd(26513,323
```
*```FLAG:-crypto{10245,-8404}```*

### *MODULAR ARITHMETIC 1*

We have find a,b from 
```
11 ≡ a mod 6
8146798528947 ≡ b mod 17
```
By doing print(11 % 6) we get 5.

By doing print(8146798528947 % 17) we get 4.

The question asnwer is the smaller number of a and b.

*```FLAG:- 4```*

### *MODULAR ARITHMETIC 2*

We have to calculate ``273246787654^65536 mod 65537``

By using **`print(pow(273246787654,65536,65537))`** we get `1`

*```FLAG:- 1```*

### *MODULAR INVERSE*

We have to find d from ``3 * d ≡ 1 mod 13``.

We can find it using **``print(pow(3, -1, 13))``**

*```FLAG:- 9```*

# ***RSA***

## ***STARTER***

### *RSA STARTER 1*
 
 We are asked to find ``101^17 mod 22663``
 
 By using ``pow(101,17,22663)``.
 
 *```FLAG:-19906```*
 
 ### *RSA STARTER 2*
 
 We are given number,exponent,p,q. By doing pxq we get n. Then by using ```pow(12,65537,391)```.
 
*```FLAG:-301```*

### *RSA STARTER 3*

We given p and q. We have to find euler's totient. ```e = (p-1) x (q-1)```

*```FLAG:-882564595536224140639625987657529300394956519977044270821168```*

### *RSA STARTER 4*

We are given p,q and e. We have to do find "d".

By using the code we get the flag.
```
from Crypto.Util.number import inverse
p = 857504083339712752489993810777
q = 1029224947942998075080348647219
e = (p-1) * (q-1)
d = inverse(65537, e)
print(d)
```
*```FLAG:-121832886702415731577073962957377780195510499965398469843281```*

### *RSA STARTER 5*

We are given n,e and c. We have to decrypt cipher using d.

By using the code we can get the flag.
```
from Crypto.Util.number import inverse
c = 77578995801157823671636298847186723593814843845525223303932
n = 882564595536224140639625987659416029426239230804614613279163
p = 857504083339712752489993810777
q = 1029224947942998075080348647219
e = (p-1) * (q-1)
d = inverse(65537, e)
print(pow(c,d,n))
```
*```FLAG:-13371337```*

### *RSA STARTER 6*

We are given n,d. We have to find the hex value using d.The value is hased with data given

By using the code the can we get the flag.
```
from Crypto.Hash import SHA256
from Crypto.Util.number import bytes_to_long

N = 15216583654836731327639981224133918855895948374072384050848479908982286890731769486609085918857664046075375253168955058743185664390273058074450390236774324903305663479046566232967297765731625328029814055635316002591227570271271445226094919864475407884459980489638001092788574811554149774028950310695112688723853763743238753349782508121985338746755237819373178699343135091783992299561827389745132880022259873387524273298850340648779897909381979714026837172003953221052431217940632552930880000919436507245150726543040714721553361063311954285289857582079880295199632757829525723874753306371990452491305564061051059885803
d = 11175901210643014262548222473449533091378848269490518850474399681690547281665059317155831692300453197335735728459259392366823302405685389586883670043744683993709123180805154631088513521456979317628012721881537154107239389466063136007337120599915456659758559300673444689263854921332185562706707573660658164991098457874495054854491474065039621922972671588299315846306069845169959451250821044417886630346229021305410340100401530146135418806544340908355106582089082980533651095594192031411679866134256418292249592135441145384466261279428795408721990564658703903787956958168449841491667690491585550160457893350536334242689

data = b'crypto{Immut4ble_m3ssag1ng}'
hash = SHA256.new(data)
S = pow(bytes_to_long(hash.digest()), d, N)

print(hex(S)[2:])
```
*```FLAG:-6ac9bb8f110b318a40ad8d7e57defdcce2652f5928b5f9b97c1504d7096d7af1d34e477b30f1a08014e8d525b14458b709a77a5fa67d4711bd19da1446f9fb0ffd9fdedc4101bdc9a4b26dd036f11d02f6b56f4926170c643f302d59c4fe8ea678b3ca91b4bb9b2024f2a839bec1514c0242b57e1f5e77999ee67c450982730252bc2c3c35acb4ac06a6ce8b9dbf84e29df0baa7369e0fd26f6dfcfb22a464e05c5b72baba8f78dc742e96542169710918ee2947749477869cb3567180ccbdfe6fdbe85bcaca4bf6da77c8f382bb4c8cd56dee43d1290ca856318c97f1756b789e3cac0c9738f5e9f797314d39a2ededb92583d97124ec6b313c4ea3464037d3```*
## ***PRIMES PART 1***

### *FACTORING*

We are given a number. We are asked divide into 2 primes.
We can use factordb to get the primes.

*```FLAG:-crypto{19704762736204164635843,25889363174021185185929}```*

### *INFERIOUS PRIME*

We are given output.txt and and .py files. In the output file we are given c,e,n.

By getting primes of n and by using this code we get the flag.
```
import gmpy2
import codecs

if __name__ == '__main__':
    c = 39207274348578481322317340648475596807303160111338236677373
    n = 742449129124467073921545687640895127535705902454369756401331
    e = 3

    p = 752708788837165590355094155871
    q = 986369682585281993933185289261

    l = gmpy2.lcm(p-1, q-1)
    gcd, u, v = gmpy2.gcdext(e, l)

    while u < 0:
        u += l
    m = pow(c, u, n)
    print(m)
    print(codecs.decode(('%x'%m),'hex_codec'))
```
*```FLAG:-crypto{N33d_b1g_pR1m35}```*

### *MONOPRIME*

We are given a output.txt. From question heading we can understand that it is monoprime it doesn't have 2 primes.

By using the code we can get the flag.
```
from Crypto.Util.number import inverse,long_to_bytes

n = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591
e = 65537
ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942 

phi = n-1
d = inverse(e,phi)
print(long_to_bytes(pow(ct, d, n)))
```
*```FLAG:-crypto{0n3_pr1m3_41n7_pr1m3_l0l}```*

### *MANYPRIMES*

We get are given output.txt . From question heading we can understand that it has more than 2 primes.

By using the code we get the flag.
```
from gmpy2 import *
import codecs

n = 580642391898843192929563856870897799650883152718761762932292482252152591279871421569162037190419036435041797739880389529593674485555792234900969402019055601781662044515999210032698275981631376651117318677368742867687180140048715627160641771118040372573575479330830092989800730105573700557717146251860588802509310534792310748898504394966263819959963273509119791037525504422606634640173277598774814099540555569257179715908642917355365791447508751401889724095964924513196281345665480688029639999472649549163147599540142367575413885729653166517595719991872223011969856259344396899748662101941230745601719730556631637

c = 320721490534624434149993723527322977960556510750628354856260732098109692581338409999983376131354918370047625150454728718467998870322344980985635149656977787964380651868131740312053755501594999166365821315043312308622388016666802478485476059625888033017198083472976011719998333985531756978678758897472845358167730221506573817798467100023754709109274265835201757369829744113233607359526441007577850111228850004361838028842815813724076511058179239339760639518034583306154826603816927757236549096339501503316601078891287408682099750164720032975016814187899399273719181407940397071512493967454225665490162619270814464

e = 65537

primes = [9282105380008121879,9303850685953812323,9389357739583927789,10336650220878499841,10638241655447339831,11282698189561966721,11328768673634243077,11403460639036243901,11473665579512371723,11492065299277279799,11530534813954192171,11665347949879312361,12132158321859677597,12834461276877415051,12955403765595949597,12973972336777979701,13099895578757581201,13572286589428162097,14100640260554622013,14178869592193599187,14278240802299816541,14523070016044624039,14963354250199553339,15364597561881860737,15669758663523555763,15824122791679574573,15998365463074268941,16656402470578844539,16898740504023346457,17138336856793050757,17174065872156629921,17281246625998849649]

totient = 1

for i in primes:
	totient *= (i - 1)

assert gcd(e, totient) == 1

d = invert(e, totient)

get_context().precision=1000

m = powmod(c, d, n)
print(m[2:-1])
print(codecs.decode(('%x'%m),'hex_codec'))
```
*```FLAG:-crypto{700_m4ny_5m4ll_f4c70r5}```*

## ***PUBLIC EXPONENT***

### *SALTY*

We are given a output.txt. In this the exponent is small e = 1 and n,ciphertext.
 
By using this code we get the flag.
```
from Crypto.Util.number import inverse,long_to_bytes

n = 110581795715958566206600392161360212579669637391437097703685154237017351570464767725324182051199901920318211290404777259728923614917211291562555864753005179326101890427669819834642007924406862482343614488768256951616086287044725034412802176312273081322195866046098595306261781788276570920467840172004530873767 
e = 1
ct = 44981230718212183604274785925793145442655465025264554046028251311164494127485 

phi = n-1
d = inverse(e,phi)
print(long_to_bytes(pow(ct, d, n)))
```
*```FLAG:-crypto{saltstack_fell_for_this!}```*

### *MODULUS_UNUTILIS*

We are given a output.txt. We are given n,e,cipher text.

By using this code we get the flag.
```
import gmpy2
import codecs

n = 17258212916191948536348548470938004244269544560039009244721959293554822498047075403658429865201816363311805874117705688359853941515579440852166618074161313773416434156467811969628473425365608002907061241714688204565170146117869742910273064909154666642642308154422770994836108669814632309362483307560217924183202838588431342622551598499747369771295105890359290073146330677383341121242366368309126850094371525078749496850520075015636716490087482193603562501577348571256210991732071282478547626856068209192987351212490642903450263288650415552403935705444809043563866466823492258216747445926536608548665086042098252335883
e = 3
cipher_str = 243251053617903760309941844835411292373350655973075480264001352919865180151222189820473358411037759381328642957324889519192337152355302808400638052620580409813222660643570085177957

gs = gmpy2.mpz(cipher_str)
gm = gmpy2.mpz(n)
ge = gmpy2.mpz(e)

root, exact = gmpy2.iroot(gs, ge)
print(codecs.decode(('%x'%root),'hex_codec'))
```
*```FLAG:-crypto{N33d_m04R_p4dd1ng}```*

### *EVERYTHING IS BIG*

We are given a output.txt. We are given n,e,cipher text.

By using this code we get the flag.
```
import gmpy2
import codecs

def continued_fraction(n, d):
    cf = []
    while d:
        q = n // d
        cf.append(q)
        n, d = d, n-d*q
    return cf

def convergents_of_contfrac(cf):
    n0, n1 = cf[0], cf[0]*cf[1]+1
    d0, d1 = 1, cf[1]
    yield (n0, d0)
    yield (n1, d1)

    for i in range(2, len(cf)):
        n2, d2 = cf[i]*n1+n0, cf[i]*d1+d0
        yield (n2, d2)
        n0, n1 = n1, n2
        d0, d1 = d1, d2

def wieners_attack(e, n):
    cf = continued_fraction(e, n)
    convergents = convergents_of_contfrac(cf)

    for k, d in convergents:
        if k == 0:
            continue
        phi, rem = divmod(e*d-1, k)
        if rem != 0:
            continue
        s = n - phi + 1
        D = s*s - 4*n
        if D > 0 and gmpy2.is_square(D):
            return d


if __name__ == '__main__':
    n = 17882358060039339138898609438175411871477799918608830364502878294884428124352650304487222941488283375369504964489843886450079011111185462712713723967554860800590884830066000037099382469037854558513800884226033482024813889617119261578740186832726330482660558112299636890899520011220715934812750994601701551700102743698011384901217438912042452845551043076325218096704501728676598844462217580321136090473356372587847867144139594128211568185994035330415437804541731112709398826340193004240100025524738143760028319395043726883002837253849402330482885844810147036036336331435599614615503162626162367298458471506712461489989
    e = 17020150076709128119083974734794181027444082538984561213457316385002227057046434624926585749829752528593484562619943378254221611402273789707344641621909587301235354100329524707868740634136536090426674571043575143643509588206167467975358621913734029724621239906525138080313643641583879006750707195361675041612917976706071422871623836736573031684273386527347331538106636557760592110474555054035119652704752522351493705235389689571190594575425975884359690828537582335216844791552006182660195930518013924320699666032058521436148104535591298587644016501482651965898477498665383282100884936846002622549396978211338460810061
    c = 13404525979748126097473495174813420602872447183137163515874424800745908465888610753614424273646556867230585716334041302414788296235957551537280962982606872739790238283352083341665600695265159866398615606445940999707112115592530367490262243190990792817478038440051246574063866414124249543246249381067426279737022156185945505900370286034722108244980586354993277510391977307681865198470046687594466202504536527770949973532056924243655648076079280163940372194706002378540202338409029918853268685707742216040130263591527267967132601287257674155827540831619548675943049297472561270988595335043005828140324687252672722445815
    d = wieners_attack(e, n)
    m = pow(c, d, n)
    print(m)
    print(codecs.decode(('%x'%m),'hex_codec'))
```
*```FLAG:-crypto{s0m3th1ng5_c4n_b3_t00_b1g}```*

## *PRIMES PART 2*

We are given a file output.txt. we are given n,e,cipher text. we have find p and q using given n.

By using the following we get the flag
```
import gmpy2
import codecs

if __name__ == '__main__':
    c = 98280456757136766244944891987028935843441533415613592591358482906016439563076150526116369842213103333480506705993633901994107281890187248495507270868621384652207697607019899166492132408348789252555196428608661320671877412710489782358282011364127799563335562917707783563681920786994453004763755404510541574502176243896756839917991848428091594919111448023948527766368304503100650379914153058191140072528095898576018893829830104362124927140555107994114143042266758709328068902664037870075742542194318059191313468675939426810988239079424823495317464035252325521917592045198152643533223015952702649249494753395100973534541766285551891859649320371178562200252228779395393974169736998523394598517174182142007480526603025578004665936854657294541338697513521007818552254811797566860763442604365744596444735991732790926343720102293453429936734206246109968817158815749927063561835274636195149702317415680401987150336994583752062565237605953153790371155918439941193401473271753038180560129784192800351649724465553733201451581525173536731674524145027931923204961274369826379325051601238308635192540223484055096203293400419816024111797903442864181965959247745006822690967920957905188441550106930799896292835287867403979631824085790047851383294389
    n = 383347712330877040452238619329524841763392526146840572232926924642094891453979246383798913394114305368360426867021623649667024217266529000859703542590316063318592391925062014229671423777796679798747131250552455356061834719512365575593221216339005132464338847195248627639623487124025890693416305788160905762011825079336880567461033322240015771102929696350161937950387427696385850443727777996483584464610046380722736790790188061964311222153985614287276995741553706506834906746892708903948496564047090014307484054609862129530262108669567834726352078060081889712109412073731026030466300060341737504223822014714056413752165841749368159510588178604096191956750941078391415634472219765129561622344109769892244712668402761549412177892054051266761597330660545704317210567759828757156904778495608968785747998059857467440128156068391746919684258227682866083662345263659558066864109212457286114506228470930775092735385388316268663664139056183180238043386636254075940621543717531670995823417070666005930452836389812129462051771646048498397195157405386923446893886593048680984896989809135802276892911038588008701926729269812453226891776546037663583893625479252643042517196958990266376741676514631089466493864064316127648074609662749196545969926051
    e = 65537

    p = 19579267410474709598749314750954211170621862561006233612440352022286786882372619130071639824109783540564512429081674132336811972404563957025465034025781206466631730784516337210291334356396471732168742739790464109881039219452504456611589154349427303832789968502204300316585544080003423669120186095188478480761108168299370326928127888786819392372477069515318179751702985809024210164243409544692708684215042226932081052831028570060308963093217622183111643335692361019897449265402290540025790581589980867847884281862216603571536255382298035337865885153328169634178323279004749915197270120323340416965014136429743252761521
    q = 19579267410474709598749314750954211170621862561006233612440352022286786882372619130071639824109783540564512429081674132336811972404563957025465034025781206466631730784516337210291334356396471732168742739790464109881039219452504456611589154349427303832789968502204300316585544080003423669120186095188478480761108168299370326928127888786819392372477069515318179751702985809024210164243409544692708684215042226932081052831028570060308963093217622183111643335692362635203582868526178838018946986792656819885261069890315500550802303622551029821058459163702751893798676443415681144429096989664473705850619792495553724950931

    l = gmpy2.lcm(p-1, q-1)
    gcd, u, v = gmpy2.gcdext(e, l)

    while u < 0:
        u += l
    m = pow(c, u, n)
    print(m)
    print(codecs.decode(('%x'%m),'hex_codec'))
```
*```FLAG:-crypto{f3rm47_w45_4_g3n1u5}```*
